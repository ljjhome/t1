// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/drivers/gnss/proto/config.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto;
namespace apollo {
namespace drivers {
namespace gnss {
namespace config {
class Config;
struct ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class NovatelConfig;
struct NovatelConfigDefaultTypeInternal;
extern NovatelConfigDefaultTypeInternal _NovatelConfig_default_instance_;
class Stream;
struct StreamDefaultTypeInternal;
extern StreamDefaultTypeInternal _Stream_default_instance_;
class Stream_Ntrip;
struct Stream_NtripDefaultTypeInternal;
extern Stream_NtripDefaultTypeInternal _Stream_Ntrip_default_instance_;
class Stream_Serial;
struct Stream_SerialDefaultTypeInternal;
extern Stream_SerialDefaultTypeInternal _Stream_Serial_default_instance_;
class Stream_Tcp;
struct Stream_TcpDefaultTypeInternal;
extern Stream_TcpDefaultTypeInternal _Stream_Tcp_default_instance_;
class Stream_Udp;
struct Stream_UdpDefaultTypeInternal;
extern Stream_UdpDefaultTypeInternal _Stream_Udp_default_instance_;
class TF;
struct TFDefaultTypeInternal;
extern TFDefaultTypeInternal _TF_default_instance_;
class UbloxConfig;
struct UbloxConfigDefaultTypeInternal;
extern UbloxConfigDefaultTypeInternal _UbloxConfig_default_instance_;
}  // namespace config
}  // namespace gnss
}  // namespace drivers
}  // namespace apollo
PROTOBUF_NAMESPACE_OPEN
template<> ::apollo::drivers::gnss::config::Config* Arena::CreateMaybeMessage<::apollo::drivers::gnss::config::Config>(Arena*);
template<> ::apollo::drivers::gnss::config::NovatelConfig* Arena::CreateMaybeMessage<::apollo::drivers::gnss::config::NovatelConfig>(Arena*);
template<> ::apollo::drivers::gnss::config::Stream* Arena::CreateMaybeMessage<::apollo::drivers::gnss::config::Stream>(Arena*);
template<> ::apollo::drivers::gnss::config::Stream_Ntrip* Arena::CreateMaybeMessage<::apollo::drivers::gnss::config::Stream_Ntrip>(Arena*);
template<> ::apollo::drivers::gnss::config::Stream_Serial* Arena::CreateMaybeMessage<::apollo::drivers::gnss::config::Stream_Serial>(Arena*);
template<> ::apollo::drivers::gnss::config::Stream_Tcp* Arena::CreateMaybeMessage<::apollo::drivers::gnss::config::Stream_Tcp>(Arena*);
template<> ::apollo::drivers::gnss::config::Stream_Udp* Arena::CreateMaybeMessage<::apollo::drivers::gnss::config::Stream_Udp>(Arena*);
template<> ::apollo::drivers::gnss::config::TF* Arena::CreateMaybeMessage<::apollo::drivers::gnss::config::TF>(Arena*);
template<> ::apollo::drivers::gnss::config::UbloxConfig* Arena::CreateMaybeMessage<::apollo::drivers::gnss::config::UbloxConfig>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace apollo {
namespace drivers {
namespace gnss {
namespace config {

enum Stream_Format : int {
  Stream_Format_UNKNOWN = 0,
  Stream_Format_NMEA = 1,
  Stream_Format_RTCM_V2 = 2,
  Stream_Format_RTCM_V3 = 3,
  Stream_Format_NOVATEL_TEXT = 10,
  Stream_Format_NOVATEL_BINARY = 11,
  Stream_Format_UBLOX_TEXT = 20,
  Stream_Format_UBLOX_BINARY = 21
};
bool Stream_Format_IsValid(int value);
constexpr Stream_Format Stream_Format_Format_MIN = Stream_Format_UNKNOWN;
constexpr Stream_Format Stream_Format_Format_MAX = Stream_Format_UBLOX_BINARY;
constexpr int Stream_Format_Format_ARRAYSIZE = Stream_Format_Format_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Stream_Format_descriptor();
template<typename T>
inline const std::string& Stream_Format_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Stream_Format>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Stream_Format_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Stream_Format_descriptor(), enum_t_value);
}
inline bool Stream_Format_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Stream_Format* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Stream_Format>(
    Stream_Format_descriptor(), name, value);
}
enum Config_RtkSolutionType : int {
  Config_RtkSolutionType_RTK_RECEIVER_SOLUTION = 1,
  Config_RtkSolutionType_RTK_SOFTWARE_SOLUTION = 2
};
bool Config_RtkSolutionType_IsValid(int value);
constexpr Config_RtkSolutionType Config_RtkSolutionType_RtkSolutionType_MIN = Config_RtkSolutionType_RTK_RECEIVER_SOLUTION;
constexpr Config_RtkSolutionType Config_RtkSolutionType_RtkSolutionType_MAX = Config_RtkSolutionType_RTK_SOFTWARE_SOLUTION;
constexpr int Config_RtkSolutionType_RtkSolutionType_ARRAYSIZE = Config_RtkSolutionType_RtkSolutionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Config_RtkSolutionType_descriptor();
template<typename T>
inline const std::string& Config_RtkSolutionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Config_RtkSolutionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Config_RtkSolutionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Config_RtkSolutionType_descriptor(), enum_t_value);
}
inline bool Config_RtkSolutionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Config_RtkSolutionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Config_RtkSolutionType>(
    Config_RtkSolutionType_descriptor(), name, value);
}
enum ImuType : int {
  IMAR_FSAS = 13,
  ISA100C = 26,
  ADIS16488 = 31,
  STIM300 = 32,
  ISA100 = 34,
  ISA100_400HZ = 38,
  ISA100C_400HZ = 39,
  CPT_XW5651 = 40,
  G320N = 41,
  UM442 = 42,
  IAM20680 = 57
};
bool ImuType_IsValid(int value);
constexpr ImuType ImuType_MIN = IMAR_FSAS;
constexpr ImuType ImuType_MAX = IAM20680;
constexpr int ImuType_ARRAYSIZE = ImuType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ImuType_descriptor();
template<typename T>
inline const std::string& ImuType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ImuType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ImuType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ImuType_descriptor(), enum_t_value);
}
inline bool ImuType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ImuType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ImuType>(
    ImuType_descriptor(), name, value);
}
// ===================================================================

class Stream_Serial final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.drivers.gnss.config.Stream.Serial) */ {
 public:
  inline Stream_Serial() : Stream_Serial(nullptr) {}
  ~Stream_Serial() override;
  explicit constexpr Stream_Serial(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Stream_Serial(const Stream_Serial& from);
  Stream_Serial(Stream_Serial&& from) noexcept
    : Stream_Serial() {
    *this = ::std::move(from);
  }

  inline Stream_Serial& operator=(const Stream_Serial& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stream_Serial& operator=(Stream_Serial&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stream_Serial& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stream_Serial* internal_default_instance() {
    return reinterpret_cast<const Stream_Serial*>(
               &_Stream_Serial_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Stream_Serial& a, Stream_Serial& b) {
    a.Swap(&b);
  }
  inline void Swap(Stream_Serial* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stream_Serial* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Stream_Serial* New() const final {
    return new Stream_Serial();
  }

  Stream_Serial* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Stream_Serial>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Stream_Serial& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Stream_Serial& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stream_Serial* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.drivers.gnss.config.Stream.Serial";
  }
  protected:
  explicit Stream_Serial(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
    kBaudRateFieldNumber = 2,
  };
  // optional bytes device = 1;
  bool has_device() const;
  private:
  bool _internal_has_device() const;
  public:
  void clear_device();
  const std::string& device() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device();
  PROTOBUF_MUST_USE_RESULT std::string* release_device();
  void set_allocated_device(std::string* device);
  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(const std::string& value);
  std::string* _internal_mutable_device();
  public:

  // optional int32 baud_rate = 2 [default = 9600];
  bool has_baud_rate() const;
  private:
  bool _internal_has_baud_rate() const;
  public:
  void clear_baud_rate();
  ::PROTOBUF_NAMESPACE_ID::int32 baud_rate() const;
  void set_baud_rate(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_baud_rate() const;
  void _internal_set_baud_rate(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.drivers.gnss.config.Stream.Serial)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_;
  ::PROTOBUF_NAMESPACE_ID::int32 baud_rate_;
  friend struct ::TableStruct_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Stream_Tcp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.drivers.gnss.config.Stream.Tcp) */ {
 public:
  inline Stream_Tcp() : Stream_Tcp(nullptr) {}
  ~Stream_Tcp() override;
  explicit constexpr Stream_Tcp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Stream_Tcp(const Stream_Tcp& from);
  Stream_Tcp(Stream_Tcp&& from) noexcept
    : Stream_Tcp() {
    *this = ::std::move(from);
  }

  inline Stream_Tcp& operator=(const Stream_Tcp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stream_Tcp& operator=(Stream_Tcp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stream_Tcp& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stream_Tcp* internal_default_instance() {
    return reinterpret_cast<const Stream_Tcp*>(
               &_Stream_Tcp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Stream_Tcp& a, Stream_Tcp& b) {
    a.Swap(&b);
  }
  inline void Swap(Stream_Tcp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stream_Tcp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Stream_Tcp* New() const final {
    return new Stream_Tcp();
  }

  Stream_Tcp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Stream_Tcp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Stream_Tcp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Stream_Tcp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stream_Tcp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.drivers.gnss.config.Stream.Tcp";
  }
  protected:
  explicit Stream_Tcp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kPortFieldNumber = 2,
  };
  // optional bytes address = 1;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // optional int32 port = 2 [default = 3001];
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::int32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.drivers.gnss.config.Stream.Tcp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_;
  friend struct ::TableStruct_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Stream_Udp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.drivers.gnss.config.Stream.Udp) */ {
 public:
  inline Stream_Udp() : Stream_Udp(nullptr) {}
  ~Stream_Udp() override;
  explicit constexpr Stream_Udp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Stream_Udp(const Stream_Udp& from);
  Stream_Udp(Stream_Udp&& from) noexcept
    : Stream_Udp() {
    *this = ::std::move(from);
  }

  inline Stream_Udp& operator=(const Stream_Udp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stream_Udp& operator=(Stream_Udp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stream_Udp& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stream_Udp* internal_default_instance() {
    return reinterpret_cast<const Stream_Udp*>(
               &_Stream_Udp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Stream_Udp& a, Stream_Udp& b) {
    a.Swap(&b);
  }
  inline void Swap(Stream_Udp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stream_Udp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Stream_Udp* New() const final {
    return new Stream_Udp();
  }

  Stream_Udp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Stream_Udp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Stream_Udp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Stream_Udp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stream_Udp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.drivers.gnss.config.Stream.Udp";
  }
  protected:
  explicit Stream_Udp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kPortFieldNumber = 2,
  };
  // optional bytes address = 1;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // optional int32 port = 2 [default = 3001];
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::int32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.drivers.gnss.config.Stream.Udp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_;
  friend struct ::TableStruct_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Stream_Ntrip final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.drivers.gnss.config.Stream.Ntrip) */ {
 public:
  inline Stream_Ntrip() : Stream_Ntrip(nullptr) {}
  ~Stream_Ntrip() override;
  explicit constexpr Stream_Ntrip(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Stream_Ntrip(const Stream_Ntrip& from);
  Stream_Ntrip(Stream_Ntrip&& from) noexcept
    : Stream_Ntrip() {
    *this = ::std::move(from);
  }

  inline Stream_Ntrip& operator=(const Stream_Ntrip& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stream_Ntrip& operator=(Stream_Ntrip&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stream_Ntrip& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stream_Ntrip* internal_default_instance() {
    return reinterpret_cast<const Stream_Ntrip*>(
               &_Stream_Ntrip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Stream_Ntrip& a, Stream_Ntrip& b) {
    a.Swap(&b);
  }
  inline void Swap(Stream_Ntrip* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stream_Ntrip* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Stream_Ntrip* New() const final {
    return new Stream_Ntrip();
  }

  Stream_Ntrip* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Stream_Ntrip>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Stream_Ntrip& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Stream_Ntrip& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stream_Ntrip* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.drivers.gnss.config.Stream.Ntrip";
  }
  protected:
  explicit Stream_Ntrip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kMountPointFieldNumber = 3,
    kUserFieldNumber = 4,
    kPasswordFieldNumber = 5,
    kPortFieldNumber = 2,
    kTimeoutSFieldNumber = 6,
  };
  // optional bytes address = 1;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // optional bytes mount_point = 3;
  bool has_mount_point() const;
  private:
  bool _internal_has_mount_point() const;
  public:
  void clear_mount_point();
  const std::string& mount_point() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mount_point(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mount_point();
  PROTOBUF_MUST_USE_RESULT std::string* release_mount_point();
  void set_allocated_mount_point(std::string* mount_point);
  private:
  const std::string& _internal_mount_point() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mount_point(const std::string& value);
  std::string* _internal_mutable_mount_point();
  public:

  // optional bytes user = 4;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_MUST_USE_RESULT std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // optional bytes password = 5;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_MUST_USE_RESULT std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // optional int32 port = 2 [default = 2101];
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::int32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional uint32 timeout_s = 6 [default = 30];
  bool has_timeout_s() const;
  private:
  bool _internal_has_timeout_s() const;
  public:
  void clear_timeout_s();
  ::PROTOBUF_NAMESPACE_ID::uint32 timeout_s() const;
  void set_timeout_s(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_timeout_s() const;
  void _internal_set_timeout_s(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.drivers.gnss.config.Stream.Ntrip)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mount_point_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_;
  ::PROTOBUF_NAMESPACE_ID::uint32 timeout_s_;
  friend struct ::TableStruct_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Stream final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.drivers.gnss.config.Stream) */ {
 public:
  inline Stream() : Stream(nullptr) {}
  ~Stream() override;
  explicit constexpr Stream(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Stream(const Stream& from);
  Stream(Stream&& from) noexcept
    : Stream() {
    *this = ::std::move(from);
  }

  inline Stream& operator=(const Stream& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stream& operator=(Stream&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stream& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kSerial = 2,
    kTcp = 3,
    kUdp = 4,
    kNtrip = 5,
    TYPE_NOT_SET = 0,
  };

  static inline const Stream* internal_default_instance() {
    return reinterpret_cast<const Stream*>(
               &_Stream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Stream& a, Stream& b) {
    a.Swap(&b);
  }
  inline void Swap(Stream* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stream* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Stream* New() const final {
    return new Stream();
  }

  Stream* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Stream>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Stream& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Stream& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stream* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.drivers.gnss.config.Stream";
  }
  protected:
  explicit Stream(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Stream_Serial Serial;
  typedef Stream_Tcp Tcp;
  typedef Stream_Udp Udp;
  typedef Stream_Ntrip Ntrip;

  typedef Stream_Format Format;
  static constexpr Format UNKNOWN =
    Stream_Format_UNKNOWN;
  static constexpr Format NMEA =
    Stream_Format_NMEA;
  static constexpr Format RTCM_V2 =
    Stream_Format_RTCM_V2;
  static constexpr Format RTCM_V3 =
    Stream_Format_RTCM_V3;
  static constexpr Format NOVATEL_TEXT =
    Stream_Format_NOVATEL_TEXT;
  static constexpr Format NOVATEL_BINARY =
    Stream_Format_NOVATEL_BINARY;
  static constexpr Format UBLOX_TEXT =
    Stream_Format_UBLOX_TEXT;
  static constexpr Format UBLOX_BINARY =
    Stream_Format_UBLOX_BINARY;
  static inline bool Format_IsValid(int value) {
    return Stream_Format_IsValid(value);
  }
  static constexpr Format Format_MIN =
    Stream_Format_Format_MIN;
  static constexpr Format Format_MAX =
    Stream_Format_Format_MAX;
  static constexpr int Format_ARRAYSIZE =
    Stream_Format_Format_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Format_descriptor() {
    return Stream_Format_descriptor();
  }
  template<typename T>
  static inline const std::string& Format_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Format>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Format_Name.");
    return Stream_Format_Name(enum_t_value);
  }
  static inline bool Format_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Format* value) {
    return Stream_Format_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFormatFieldNumber = 1,
    kPushLocationFieldNumber = 6,
    kSerialFieldNumber = 2,
    kTcpFieldNumber = 3,
    kUdpFieldNumber = 4,
    kNtripFieldNumber = 5,
  };
  // optional .apollo.drivers.gnss.config.Stream.Format format = 1;
  bool has_format() const;
  private:
  bool _internal_has_format() const;
  public:
  void clear_format();
  ::apollo::drivers::gnss::config::Stream_Format format() const;
  void set_format(::apollo::drivers::gnss::config::Stream_Format value);
  private:
  ::apollo::drivers::gnss::config::Stream_Format _internal_format() const;
  void _internal_set_format(::apollo::drivers::gnss::config::Stream_Format value);
  public:

  // optional bool push_location = 6;
  bool has_push_location() const;
  private:
  bool _internal_has_push_location() const;
  public:
  void clear_push_location();
  bool push_location() const;
  void set_push_location(bool value);
  private:
  bool _internal_push_location() const;
  void _internal_set_push_location(bool value);
  public:

  // .apollo.drivers.gnss.config.Stream.Serial serial = 2;
  bool has_serial() const;
  private:
  bool _internal_has_serial() const;
  public:
  void clear_serial();
  const ::apollo::drivers::gnss::config::Stream_Serial& serial() const;
  PROTOBUF_MUST_USE_RESULT ::apollo::drivers::gnss::config::Stream_Serial* release_serial();
  ::apollo::drivers::gnss::config::Stream_Serial* mutable_serial();
  void set_allocated_serial(::apollo::drivers::gnss::config::Stream_Serial* serial);
  private:
  const ::apollo::drivers::gnss::config::Stream_Serial& _internal_serial() const;
  ::apollo::drivers::gnss::config::Stream_Serial* _internal_mutable_serial();
  public:
  void unsafe_arena_set_allocated_serial(
      ::apollo::drivers::gnss::config::Stream_Serial* serial);
  ::apollo::drivers::gnss::config::Stream_Serial* unsafe_arena_release_serial();

  // .apollo.drivers.gnss.config.Stream.Tcp tcp = 3;
  bool has_tcp() const;
  private:
  bool _internal_has_tcp() const;
  public:
  void clear_tcp();
  const ::apollo::drivers::gnss::config::Stream_Tcp& tcp() const;
  PROTOBUF_MUST_USE_RESULT ::apollo::drivers::gnss::config::Stream_Tcp* release_tcp();
  ::apollo::drivers::gnss::config::Stream_Tcp* mutable_tcp();
  void set_allocated_tcp(::apollo::drivers::gnss::config::Stream_Tcp* tcp);
  private:
  const ::apollo::drivers::gnss::config::Stream_Tcp& _internal_tcp() const;
  ::apollo::drivers::gnss::config::Stream_Tcp* _internal_mutable_tcp();
  public:
  void unsafe_arena_set_allocated_tcp(
      ::apollo::drivers::gnss::config::Stream_Tcp* tcp);
  ::apollo::drivers::gnss::config::Stream_Tcp* unsafe_arena_release_tcp();

  // .apollo.drivers.gnss.config.Stream.Udp udp = 4;
  bool has_udp() const;
  private:
  bool _internal_has_udp() const;
  public:
  void clear_udp();
  const ::apollo::drivers::gnss::config::Stream_Udp& udp() const;
  PROTOBUF_MUST_USE_RESULT ::apollo::drivers::gnss::config::Stream_Udp* release_udp();
  ::apollo::drivers::gnss::config::Stream_Udp* mutable_udp();
  void set_allocated_udp(::apollo::drivers::gnss::config::Stream_Udp* udp);
  private:
  const ::apollo::drivers::gnss::config::Stream_Udp& _internal_udp() const;
  ::apollo::drivers::gnss::config::Stream_Udp* _internal_mutable_udp();
  public:
  void unsafe_arena_set_allocated_udp(
      ::apollo::drivers::gnss::config::Stream_Udp* udp);
  ::apollo::drivers::gnss::config::Stream_Udp* unsafe_arena_release_udp();

  // .apollo.drivers.gnss.config.Stream.Ntrip ntrip = 5;
  bool has_ntrip() const;
  private:
  bool _internal_has_ntrip() const;
  public:
  void clear_ntrip();
  const ::apollo::drivers::gnss::config::Stream_Ntrip& ntrip() const;
  PROTOBUF_MUST_USE_RESULT ::apollo::drivers::gnss::config::Stream_Ntrip* release_ntrip();
  ::apollo::drivers::gnss::config::Stream_Ntrip* mutable_ntrip();
  void set_allocated_ntrip(::apollo::drivers::gnss::config::Stream_Ntrip* ntrip);
  private:
  const ::apollo::drivers::gnss::config::Stream_Ntrip& _internal_ntrip() const;
  ::apollo::drivers::gnss::config::Stream_Ntrip* _internal_mutable_ntrip();
  public:
  void unsafe_arena_set_allocated_ntrip(
      ::apollo::drivers::gnss::config::Stream_Ntrip* ntrip);
  ::apollo::drivers::gnss::config::Stream_Ntrip* unsafe_arena_release_ntrip();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:apollo.drivers.gnss.config.Stream)
 private:
  class _Internal;
  void set_has_serial();
  void set_has_tcp();
  void set_has_udp();
  void set_has_ntrip();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int format_;
  bool push_location_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::apollo::drivers::gnss::config::Stream_Serial* serial_;
    ::apollo::drivers::gnss::config::Stream_Tcp* tcp_;
    ::apollo::drivers::gnss::config::Stream_Udp* udp_;
    ::apollo::drivers::gnss::config::Stream_Ntrip* ntrip_;
  } type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class NovatelConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.drivers.gnss.config.NovatelConfig) */ {
 public:
  inline NovatelConfig() : NovatelConfig(nullptr) {}
  ~NovatelConfig() override;
  explicit constexpr NovatelConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NovatelConfig(const NovatelConfig& from);
  NovatelConfig(NovatelConfig&& from) noexcept
    : NovatelConfig() {
    *this = ::std::move(from);
  }

  inline NovatelConfig& operator=(const NovatelConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline NovatelConfig& operator=(NovatelConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NovatelConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const NovatelConfig* internal_default_instance() {
    return reinterpret_cast<const NovatelConfig*>(
               &_NovatelConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NovatelConfig& a, NovatelConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(NovatelConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NovatelConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NovatelConfig* New() const final {
    return new NovatelConfig();
  }

  NovatelConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NovatelConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NovatelConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NovatelConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NovatelConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.drivers.gnss.config.NovatelConfig";
  }
  protected:
  explicit NovatelConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImuOrientationFieldNumber = 1,
  };
  // optional int32 imu_orientation = 1 [default = 5];
  bool has_imu_orientation() const;
  private:
  bool _internal_has_imu_orientation() const;
  public:
  void clear_imu_orientation();
  ::PROTOBUF_NAMESPACE_ID::int32 imu_orientation() const;
  void set_imu_orientation(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_imu_orientation() const;
  void _internal_set_imu_orientation(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.drivers.gnss.config.NovatelConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 imu_orientation_;
  friend struct ::TableStruct_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class UbloxConfig final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:apollo.drivers.gnss.config.UbloxConfig) */ {
 public:
  inline UbloxConfig() : UbloxConfig(nullptr) {}
  explicit constexpr UbloxConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UbloxConfig(const UbloxConfig& from);
  UbloxConfig(UbloxConfig&& from) noexcept
    : UbloxConfig() {
    *this = ::std::move(from);
  }

  inline UbloxConfig& operator=(const UbloxConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline UbloxConfig& operator=(UbloxConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UbloxConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const UbloxConfig* internal_default_instance() {
    return reinterpret_cast<const UbloxConfig*>(
               &_UbloxConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UbloxConfig& a, UbloxConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(UbloxConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UbloxConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UbloxConfig* New() const final {
    return new UbloxConfig();
  }

  UbloxConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UbloxConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UbloxConfig& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UbloxConfig& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.drivers.gnss.config.UbloxConfig";
  }
  protected:
  explicit UbloxConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.drivers.gnss.config.UbloxConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class TF final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.drivers.gnss.config.TF) */ {
 public:
  inline TF() : TF(nullptr) {}
  ~TF() override;
  explicit constexpr TF(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TF(const TF& from);
  TF(TF&& from) noexcept
    : TF() {
    *this = ::std::move(from);
  }

  inline TF& operator=(const TF& from) {
    CopyFrom(from);
    return *this;
  }
  inline TF& operator=(TF&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TF& default_instance() {
    return *internal_default_instance();
  }
  static inline const TF* internal_default_instance() {
    return reinterpret_cast<const TF*>(
               &_TF_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TF& a, TF& b) {
    a.Swap(&b);
  }
  inline void Swap(TF* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TF* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TF* New() const final {
    return new TF();
  }

  TF* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TF>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TF& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TF& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TF* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.drivers.gnss.config.TF";
  }
  protected:
  explicit TF(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameIdFieldNumber = 1,
    kChildFrameIdFieldNumber = 2,
    kEnableFieldNumber = 3,
  };
  // optional string frame_id = 1 [default = "world"];
  bool has_frame_id() const;
  private:
  bool _internal_has_frame_id() const;
  public:
  void clear_frame_id();
  const std::string& frame_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_frame_id();
  void set_allocated_frame_id(std::string* frame_id);
  private:
  const std::string& _internal_frame_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_id(const std::string& value);
  std::string* _internal_mutable_frame_id();
  public:

  // optional string child_frame_id = 2 [default = "novatel"];
  bool has_child_frame_id() const;
  private:
  bool _internal_has_child_frame_id() const;
  public:
  void clear_child_frame_id();
  const std::string& child_frame_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_child_frame_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_child_frame_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_child_frame_id();
  void set_allocated_child_frame_id(std::string* child_frame_id);
  private:
  const std::string& _internal_child_frame_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_child_frame_id(const std::string& value);
  std::string* _internal_mutable_child_frame_id();
  public:

  // optional bool enable = 3 [default = false];
  bool has_enable() const;
  private:
  bool _internal_has_enable() const;
  public:
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.drivers.gnss.config.TF)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_frame_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_id_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_child_frame_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr child_frame_id_;
  bool enable_;
  friend struct ::TableStruct_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Config final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.drivers.gnss.config.Config) */ {
 public:
  inline Config() : Config(nullptr) {}
  ~Config() override;
  explicit constexpr Config(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Config(const Config& from);
  Config(Config&& from) noexcept
    : Config() {
    *this = ::std::move(from);
  }

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config& operator=(Config&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config& default_instance() {
    return *internal_default_instance();
  }
  enum DeviceConfigCase {
    kNovatelConfig = 7,
    kUbloxConfig = 8,
    DEVICE_CONFIG_NOT_SET = 0,
  };

  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Config& a, Config& b) {
    a.Swap(&b);
  }
  inline void Swap(Config* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Config* New() const final {
    return new Config();
  }

  Config* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Config>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Config& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Config& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.drivers.gnss.config.Config";
  }
  protected:
  explicit Config(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Config_RtkSolutionType RtkSolutionType;
  static constexpr RtkSolutionType RTK_RECEIVER_SOLUTION =
    Config_RtkSolutionType_RTK_RECEIVER_SOLUTION;
  static constexpr RtkSolutionType RTK_SOFTWARE_SOLUTION =
    Config_RtkSolutionType_RTK_SOFTWARE_SOLUTION;
  static inline bool RtkSolutionType_IsValid(int value) {
    return Config_RtkSolutionType_IsValid(value);
  }
  static constexpr RtkSolutionType RtkSolutionType_MIN =
    Config_RtkSolutionType_RtkSolutionType_MIN;
  static constexpr RtkSolutionType RtkSolutionType_MAX =
    Config_RtkSolutionType_RtkSolutionType_MAX;
  static constexpr int RtkSolutionType_ARRAYSIZE =
    Config_RtkSolutionType_RtkSolutionType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RtkSolutionType_descriptor() {
    return Config_RtkSolutionType_descriptor();
  }
  template<typename T>
  static inline const std::string& RtkSolutionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RtkSolutionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RtkSolutionType_Name.");
    return Config_RtkSolutionType_Name(enum_t_value);
  }
  static inline bool RtkSolutionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RtkSolutionType* value) {
    return Config_RtkSolutionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLoginCommandsFieldNumber = 5,
    kLogoutCommandsFieldNumber = 6,
    kProj4TextFieldNumber = 11,
    kWheelParametersFieldNumber = 13,
    kGpsbinFolderFieldNumber = 14,
    kDataFieldNumber = 1,
    kCommandFieldNumber = 2,
    kRtkFromFieldNumber = 3,
    kRtkToFieldNumber = 4,
    kTfFieldNumber = 12,
    kRtkSolutionTypeFieldNumber = 9,
    kImuTypeFieldNumber = 10,
    kNovatelConfigFieldNumber = 7,
    kUbloxConfigFieldNumber = 8,
  };
  // repeated bytes login_commands = 5;
  int login_commands_size() const;
  private:
  int _internal_login_commands_size() const;
  public:
  void clear_login_commands();
  const std::string& login_commands(int index) const;
  std::string* mutable_login_commands(int index);
  void set_login_commands(int index, const std::string& value);
  void set_login_commands(int index, std::string&& value);
  void set_login_commands(int index, const char* value);
  void set_login_commands(int index, const void* value, size_t size);
  std::string* add_login_commands();
  void add_login_commands(const std::string& value);
  void add_login_commands(std::string&& value);
  void add_login_commands(const char* value);
  void add_login_commands(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& login_commands() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_login_commands();
  private:
  const std::string& _internal_login_commands(int index) const;
  std::string* _internal_add_login_commands();
  public:

  // repeated bytes logout_commands = 6;
  int logout_commands_size() const;
  private:
  int _internal_logout_commands_size() const;
  public:
  void clear_logout_commands();
  const std::string& logout_commands(int index) const;
  std::string* mutable_logout_commands(int index);
  void set_logout_commands(int index, const std::string& value);
  void set_logout_commands(int index, std::string&& value);
  void set_logout_commands(int index, const char* value);
  void set_logout_commands(int index, const void* value, size_t size);
  std::string* add_logout_commands();
  void add_logout_commands(const std::string& value);
  void add_logout_commands(std::string&& value);
  void add_logout_commands(const char* value);
  void add_logout_commands(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& logout_commands() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_logout_commands();
  private:
  const std::string& _internal_logout_commands(int index) const;
  std::string* _internal_add_logout_commands();
  public:

  // optional string proj4_text = 11;
  bool has_proj4_text() const;
  private:
  bool _internal_has_proj4_text() const;
  public:
  void clear_proj4_text();
  const std::string& proj4_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_proj4_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_proj4_text();
  PROTOBUF_MUST_USE_RESULT std::string* release_proj4_text();
  void set_allocated_proj4_text(std::string* proj4_text);
  private:
  const std::string& _internal_proj4_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proj4_text(const std::string& value);
  std::string* _internal_mutable_proj4_text();
  public:

  // optional string wheel_parameters = 13;
  bool has_wheel_parameters() const;
  private:
  bool _internal_has_wheel_parameters() const;
  public:
  void clear_wheel_parameters();
  const std::string& wheel_parameters() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_wheel_parameters(ArgT0&& arg0, ArgT... args);
  std::string* mutable_wheel_parameters();
  PROTOBUF_MUST_USE_RESULT std::string* release_wheel_parameters();
  void set_allocated_wheel_parameters(std::string* wheel_parameters);
  private:
  const std::string& _internal_wheel_parameters() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wheel_parameters(const std::string& value);
  std::string* _internal_mutable_wheel_parameters();
  public:

  // optional string gpsbin_folder = 14;
  bool has_gpsbin_folder() const;
  private:
  bool _internal_has_gpsbin_folder() const;
  public:
  void clear_gpsbin_folder();
  const std::string& gpsbin_folder() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gpsbin_folder(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gpsbin_folder();
  PROTOBUF_MUST_USE_RESULT std::string* release_gpsbin_folder();
  void set_allocated_gpsbin_folder(std::string* gpsbin_folder);
  private:
  const std::string& _internal_gpsbin_folder() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gpsbin_folder(const std::string& value);
  std::string* _internal_mutable_gpsbin_folder();
  public:

  // optional .apollo.drivers.gnss.config.Stream data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::apollo::drivers::gnss::config::Stream& data() const;
  PROTOBUF_MUST_USE_RESULT ::apollo::drivers::gnss::config::Stream* release_data();
  ::apollo::drivers::gnss::config::Stream* mutable_data();
  void set_allocated_data(::apollo::drivers::gnss::config::Stream* data);
  private:
  const ::apollo::drivers::gnss::config::Stream& _internal_data() const;
  ::apollo::drivers::gnss::config::Stream* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::apollo::drivers::gnss::config::Stream* data);
  ::apollo::drivers::gnss::config::Stream* unsafe_arena_release_data();

  // optional .apollo.drivers.gnss.config.Stream command = 2;
  bool has_command() const;
  private:
  bool _internal_has_command() const;
  public:
  void clear_command();
  const ::apollo::drivers::gnss::config::Stream& command() const;
  PROTOBUF_MUST_USE_RESULT ::apollo::drivers::gnss::config::Stream* release_command();
  ::apollo::drivers::gnss::config::Stream* mutable_command();
  void set_allocated_command(::apollo::drivers::gnss::config::Stream* command);
  private:
  const ::apollo::drivers::gnss::config::Stream& _internal_command() const;
  ::apollo::drivers::gnss::config::Stream* _internal_mutable_command();
  public:
  void unsafe_arena_set_allocated_command(
      ::apollo::drivers::gnss::config::Stream* command);
  ::apollo::drivers::gnss::config::Stream* unsafe_arena_release_command();

  // optional .apollo.drivers.gnss.config.Stream rtk_from = 3;
  bool has_rtk_from() const;
  private:
  bool _internal_has_rtk_from() const;
  public:
  void clear_rtk_from();
  const ::apollo::drivers::gnss::config::Stream& rtk_from() const;
  PROTOBUF_MUST_USE_RESULT ::apollo::drivers::gnss::config::Stream* release_rtk_from();
  ::apollo::drivers::gnss::config::Stream* mutable_rtk_from();
  void set_allocated_rtk_from(::apollo::drivers::gnss::config::Stream* rtk_from);
  private:
  const ::apollo::drivers::gnss::config::Stream& _internal_rtk_from() const;
  ::apollo::drivers::gnss::config::Stream* _internal_mutable_rtk_from();
  public:
  void unsafe_arena_set_allocated_rtk_from(
      ::apollo::drivers::gnss::config::Stream* rtk_from);
  ::apollo::drivers::gnss::config::Stream* unsafe_arena_release_rtk_from();

  // optional .apollo.drivers.gnss.config.Stream rtk_to = 4;
  bool has_rtk_to() const;
  private:
  bool _internal_has_rtk_to() const;
  public:
  void clear_rtk_to();
  const ::apollo::drivers::gnss::config::Stream& rtk_to() const;
  PROTOBUF_MUST_USE_RESULT ::apollo::drivers::gnss::config::Stream* release_rtk_to();
  ::apollo::drivers::gnss::config::Stream* mutable_rtk_to();
  void set_allocated_rtk_to(::apollo::drivers::gnss::config::Stream* rtk_to);
  private:
  const ::apollo::drivers::gnss::config::Stream& _internal_rtk_to() const;
  ::apollo::drivers::gnss::config::Stream* _internal_mutable_rtk_to();
  public:
  void unsafe_arena_set_allocated_rtk_to(
      ::apollo::drivers::gnss::config::Stream* rtk_to);
  ::apollo::drivers::gnss::config::Stream* unsafe_arena_release_rtk_to();

  // optional .apollo.drivers.gnss.config.TF tf = 12;
  bool has_tf() const;
  private:
  bool _internal_has_tf() const;
  public:
  void clear_tf();
  const ::apollo::drivers::gnss::config::TF& tf() const;
  PROTOBUF_MUST_USE_RESULT ::apollo::drivers::gnss::config::TF* release_tf();
  ::apollo::drivers::gnss::config::TF* mutable_tf();
  void set_allocated_tf(::apollo::drivers::gnss::config::TF* tf);
  private:
  const ::apollo::drivers::gnss::config::TF& _internal_tf() const;
  ::apollo::drivers::gnss::config::TF* _internal_mutable_tf();
  public:
  void unsafe_arena_set_allocated_tf(
      ::apollo::drivers::gnss::config::TF* tf);
  ::apollo::drivers::gnss::config::TF* unsafe_arena_release_tf();

  // optional .apollo.drivers.gnss.config.Config.RtkSolutionType rtk_solution_type = 9;
  bool has_rtk_solution_type() const;
  private:
  bool _internal_has_rtk_solution_type() const;
  public:
  void clear_rtk_solution_type();
  ::apollo::drivers::gnss::config::Config_RtkSolutionType rtk_solution_type() const;
  void set_rtk_solution_type(::apollo::drivers::gnss::config::Config_RtkSolutionType value);
  private:
  ::apollo::drivers::gnss::config::Config_RtkSolutionType _internal_rtk_solution_type() const;
  void _internal_set_rtk_solution_type(::apollo::drivers::gnss::config::Config_RtkSolutionType value);
  public:

  // optional .apollo.drivers.gnss.config.ImuType imu_type = 10;
  bool has_imu_type() const;
  private:
  bool _internal_has_imu_type() const;
  public:
  void clear_imu_type();
  ::apollo::drivers::gnss::config::ImuType imu_type() const;
  void set_imu_type(::apollo::drivers::gnss::config::ImuType value);
  private:
  ::apollo::drivers::gnss::config::ImuType _internal_imu_type() const;
  void _internal_set_imu_type(::apollo::drivers::gnss::config::ImuType value);
  public:

  // .apollo.drivers.gnss.config.NovatelConfig novatel_config = 7;
  bool has_novatel_config() const;
  private:
  bool _internal_has_novatel_config() const;
  public:
  void clear_novatel_config();
  const ::apollo::drivers::gnss::config::NovatelConfig& novatel_config() const;
  PROTOBUF_MUST_USE_RESULT ::apollo::drivers::gnss::config::NovatelConfig* release_novatel_config();
  ::apollo::drivers::gnss::config::NovatelConfig* mutable_novatel_config();
  void set_allocated_novatel_config(::apollo::drivers::gnss::config::NovatelConfig* novatel_config);
  private:
  const ::apollo::drivers::gnss::config::NovatelConfig& _internal_novatel_config() const;
  ::apollo::drivers::gnss::config::NovatelConfig* _internal_mutable_novatel_config();
  public:
  void unsafe_arena_set_allocated_novatel_config(
      ::apollo::drivers::gnss::config::NovatelConfig* novatel_config);
  ::apollo::drivers::gnss::config::NovatelConfig* unsafe_arena_release_novatel_config();

  // .apollo.drivers.gnss.config.UbloxConfig ublox_config = 8;
  bool has_ublox_config() const;
  private:
  bool _internal_has_ublox_config() const;
  public:
  void clear_ublox_config();
  const ::apollo::drivers::gnss::config::UbloxConfig& ublox_config() const;
  PROTOBUF_MUST_USE_RESULT ::apollo::drivers::gnss::config::UbloxConfig* release_ublox_config();
  ::apollo::drivers::gnss::config::UbloxConfig* mutable_ublox_config();
  void set_allocated_ublox_config(::apollo::drivers::gnss::config::UbloxConfig* ublox_config);
  private:
  const ::apollo::drivers::gnss::config::UbloxConfig& _internal_ublox_config() const;
  ::apollo::drivers::gnss::config::UbloxConfig* _internal_mutable_ublox_config();
  public:
  void unsafe_arena_set_allocated_ublox_config(
      ::apollo::drivers::gnss::config::UbloxConfig* ublox_config);
  ::apollo::drivers::gnss::config::UbloxConfig* unsafe_arena_release_ublox_config();

  void clear_device_config();
  DeviceConfigCase device_config_case() const;
  // @@protoc_insertion_point(class_scope:apollo.drivers.gnss.config.Config)
 private:
  class _Internal;
  void set_has_novatel_config();
  void set_has_ublox_config();

  inline bool has_device_config() const;
  inline void clear_has_device_config();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> login_commands_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> logout_commands_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proj4_text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wheel_parameters_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gpsbin_folder_;
  ::apollo::drivers::gnss::config::Stream* data_;
  ::apollo::drivers::gnss::config::Stream* command_;
  ::apollo::drivers::gnss::config::Stream* rtk_from_;
  ::apollo::drivers::gnss::config::Stream* rtk_to_;
  ::apollo::drivers::gnss::config::TF* tf_;
  int rtk_solution_type_;
  int imu_type_;
  union DeviceConfigUnion {
    constexpr DeviceConfigUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::apollo::drivers::gnss::config::NovatelConfig* novatel_config_;
    ::apollo::drivers::gnss::config::UbloxConfig* ublox_config_;
  } device_config_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Stream_Serial

// optional bytes device = 1;
inline bool Stream_Serial::_internal_has_device() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Stream_Serial::has_device() const {
  return _internal_has_device();
}
inline void Stream_Serial::clear_device() {
  device_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Stream_Serial::device() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.Serial.device)
  return _internal_device();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stream_Serial::set_device(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 device_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Stream.Serial.device)
}
inline std::string* Stream_Serial::mutable_device() {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Stream.Serial.device)
  return _s;
}
inline const std::string& Stream_Serial::_internal_device() const {
  return device_.Get();
}
inline void Stream_Serial::_internal_set_device(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  device_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Stream_Serial::_internal_mutable_device() {
  _has_bits_[0] |= 0x00000001u;
  return device_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Stream_Serial::release_device() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Stream.Serial.device)
  if (!_internal_has_device()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return device_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Stream_Serial::set_allocated_device(std::string* device) {
  if (device != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  device_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Stream.Serial.device)
}

// optional int32 baud_rate = 2 [default = 9600];
inline bool Stream_Serial::_internal_has_baud_rate() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Stream_Serial::has_baud_rate() const {
  return _internal_has_baud_rate();
}
inline void Stream_Serial::clear_baud_rate() {
  baud_rate_ = 9600;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Stream_Serial::_internal_baud_rate() const {
  return baud_rate_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Stream_Serial::baud_rate() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.Serial.baud_rate)
  return _internal_baud_rate();
}
inline void Stream_Serial::_internal_set_baud_rate(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  baud_rate_ = value;
}
inline void Stream_Serial::set_baud_rate(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_baud_rate(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Stream.Serial.baud_rate)
}

// -------------------------------------------------------------------

// Stream_Tcp

// optional bytes address = 1;
inline bool Stream_Tcp::_internal_has_address() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Stream_Tcp::has_address() const {
  return _internal_has_address();
}
inline void Stream_Tcp::clear_address() {
  address_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Stream_Tcp::address() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.Tcp.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stream_Tcp::set_address(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Stream.Tcp.address)
}
inline std::string* Stream_Tcp::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Stream.Tcp.address)
  return _s;
}
inline const std::string& Stream_Tcp::_internal_address() const {
  return address_.Get();
}
inline void Stream_Tcp::_internal_set_address(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Stream_Tcp::_internal_mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Stream_Tcp::release_address() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Stream.Tcp.address)
  if (!_internal_has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Stream_Tcp::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Stream.Tcp.address)
}

// optional int32 port = 2 [default = 3001];
inline bool Stream_Tcp::_internal_has_port() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Stream_Tcp::has_port() const {
  return _internal_has_port();
}
inline void Stream_Tcp::clear_port() {
  port_ = 3001;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Stream_Tcp::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Stream_Tcp::port() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.Tcp.port)
  return _internal_port();
}
inline void Stream_Tcp::_internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  port_ = value;
}
inline void Stream_Tcp::set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Stream.Tcp.port)
}

// -------------------------------------------------------------------

// Stream_Udp

// optional bytes address = 1;
inline bool Stream_Udp::_internal_has_address() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Stream_Udp::has_address() const {
  return _internal_has_address();
}
inline void Stream_Udp::clear_address() {
  address_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Stream_Udp::address() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.Udp.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stream_Udp::set_address(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Stream.Udp.address)
}
inline std::string* Stream_Udp::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Stream.Udp.address)
  return _s;
}
inline const std::string& Stream_Udp::_internal_address() const {
  return address_.Get();
}
inline void Stream_Udp::_internal_set_address(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Stream_Udp::_internal_mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Stream_Udp::release_address() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Stream.Udp.address)
  if (!_internal_has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Stream_Udp::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Stream.Udp.address)
}

// optional int32 port = 2 [default = 3001];
inline bool Stream_Udp::_internal_has_port() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Stream_Udp::has_port() const {
  return _internal_has_port();
}
inline void Stream_Udp::clear_port() {
  port_ = 3001;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Stream_Udp::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Stream_Udp::port() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.Udp.port)
  return _internal_port();
}
inline void Stream_Udp::_internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  port_ = value;
}
inline void Stream_Udp::set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Stream.Udp.port)
}

// -------------------------------------------------------------------

// Stream_Ntrip

// optional bytes address = 1;
inline bool Stream_Ntrip::_internal_has_address() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Stream_Ntrip::has_address() const {
  return _internal_has_address();
}
inline void Stream_Ntrip::clear_address() {
  address_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Stream_Ntrip::address() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.Ntrip.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stream_Ntrip::set_address(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Stream.Ntrip.address)
}
inline std::string* Stream_Ntrip::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Stream.Ntrip.address)
  return _s;
}
inline const std::string& Stream_Ntrip::_internal_address() const {
  return address_.Get();
}
inline void Stream_Ntrip::_internal_set_address(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Stream_Ntrip::_internal_mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Stream_Ntrip::release_address() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Stream.Ntrip.address)
  if (!_internal_has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Stream_Ntrip::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Stream.Ntrip.address)
}

// optional int32 port = 2 [default = 2101];
inline bool Stream_Ntrip::_internal_has_port() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Stream_Ntrip::has_port() const {
  return _internal_has_port();
}
inline void Stream_Ntrip::clear_port() {
  port_ = 2101;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Stream_Ntrip::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Stream_Ntrip::port() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.Ntrip.port)
  return _internal_port();
}
inline void Stream_Ntrip::_internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  port_ = value;
}
inline void Stream_Ntrip::set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Stream.Ntrip.port)
}

// optional bytes mount_point = 3;
inline bool Stream_Ntrip::_internal_has_mount_point() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Stream_Ntrip::has_mount_point() const {
  return _internal_has_mount_point();
}
inline void Stream_Ntrip::clear_mount_point() {
  mount_point_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Stream_Ntrip::mount_point() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.Ntrip.mount_point)
  return _internal_mount_point();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stream_Ntrip::set_mount_point(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 mount_point_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Stream.Ntrip.mount_point)
}
inline std::string* Stream_Ntrip::mutable_mount_point() {
  std::string* _s = _internal_mutable_mount_point();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Stream.Ntrip.mount_point)
  return _s;
}
inline const std::string& Stream_Ntrip::_internal_mount_point() const {
  return mount_point_.Get();
}
inline void Stream_Ntrip::_internal_set_mount_point(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  mount_point_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Stream_Ntrip::_internal_mutable_mount_point() {
  _has_bits_[0] |= 0x00000002u;
  return mount_point_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Stream_Ntrip::release_mount_point() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Stream.Ntrip.mount_point)
  if (!_internal_has_mount_point()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return mount_point_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Stream_Ntrip::set_allocated_mount_point(std::string* mount_point) {
  if (mount_point != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  mount_point_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mount_point,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Stream.Ntrip.mount_point)
}

// optional bytes user = 4;
inline bool Stream_Ntrip::_internal_has_user() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Stream_Ntrip::has_user() const {
  return _internal_has_user();
}
inline void Stream_Ntrip::clear_user() {
  user_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Stream_Ntrip::user() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.Ntrip.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stream_Ntrip::set_user(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 user_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Stream.Ntrip.user)
}
inline std::string* Stream_Ntrip::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Stream.Ntrip.user)
  return _s;
}
inline const std::string& Stream_Ntrip::_internal_user() const {
  return user_.Get();
}
inline void Stream_Ntrip::_internal_set_user(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  user_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Stream_Ntrip::_internal_mutable_user() {
  _has_bits_[0] |= 0x00000004u;
  return user_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Stream_Ntrip::release_user() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Stream.Ntrip.user)
  if (!_internal_has_user()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return user_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Stream_Ntrip::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  user_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Stream.Ntrip.user)
}

// optional bytes password = 5;
inline bool Stream_Ntrip::_internal_has_password() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Stream_Ntrip::has_password() const {
  return _internal_has_password();
}
inline void Stream_Ntrip::clear_password() {
  password_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Stream_Ntrip::password() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.Ntrip.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stream_Ntrip::set_password(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 password_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Stream.Ntrip.password)
}
inline std::string* Stream_Ntrip::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Stream.Ntrip.password)
  return _s;
}
inline const std::string& Stream_Ntrip::_internal_password() const {
  return password_.Get();
}
inline void Stream_Ntrip::_internal_set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Stream_Ntrip::_internal_mutable_password() {
  _has_bits_[0] |= 0x00000008u;
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Stream_Ntrip::release_password() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Stream.Ntrip.password)
  if (!_internal_has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Stream_Ntrip::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Stream.Ntrip.password)
}

// optional uint32 timeout_s = 6 [default = 30];
inline bool Stream_Ntrip::_internal_has_timeout_s() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Stream_Ntrip::has_timeout_s() const {
  return _internal_has_timeout_s();
}
inline void Stream_Ntrip::clear_timeout_s() {
  timeout_s_ = 30u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Stream_Ntrip::_internal_timeout_s() const {
  return timeout_s_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Stream_Ntrip::timeout_s() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.Ntrip.timeout_s)
  return _internal_timeout_s();
}
inline void Stream_Ntrip::_internal_set_timeout_s(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  timeout_s_ = value;
}
inline void Stream_Ntrip::set_timeout_s(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_timeout_s(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Stream.Ntrip.timeout_s)
}

// -------------------------------------------------------------------

// Stream

// optional .apollo.drivers.gnss.config.Stream.Format format = 1;
inline bool Stream::_internal_has_format() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Stream::has_format() const {
  return _internal_has_format();
}
inline void Stream::clear_format() {
  format_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::drivers::gnss::config::Stream_Format Stream::_internal_format() const {
  return static_cast< ::apollo::drivers::gnss::config::Stream_Format >(format_);
}
inline ::apollo::drivers::gnss::config::Stream_Format Stream::format() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.format)
  return _internal_format();
}
inline void Stream::_internal_set_format(::apollo::drivers::gnss::config::Stream_Format value) {
  assert(::apollo::drivers::gnss::config::Stream_Format_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  format_ = value;
}
inline void Stream::set_format(::apollo::drivers::gnss::config::Stream_Format value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Stream.format)
}

// .apollo.drivers.gnss.config.Stream.Serial serial = 2;
inline bool Stream::_internal_has_serial() const {
  return type_case() == kSerial;
}
inline bool Stream::has_serial() const {
  return _internal_has_serial();
}
inline void Stream::set_has_serial() {
  _oneof_case_[0] = kSerial;
}
inline void Stream::clear_serial() {
  if (_internal_has_serial()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.serial_;
    }
    clear_has_type();
  }
}
inline ::apollo::drivers::gnss::config::Stream_Serial* Stream::release_serial() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Stream.serial)
  if (_internal_has_serial()) {
    clear_has_type();
      ::apollo::drivers::gnss::config::Stream_Serial* temp = type_.serial_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.serial_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::drivers::gnss::config::Stream_Serial& Stream::_internal_serial() const {
  return _internal_has_serial()
      ? *type_.serial_
      : reinterpret_cast< ::apollo::drivers::gnss::config::Stream_Serial&>(::apollo::drivers::gnss::config::_Stream_Serial_default_instance_);
}
inline const ::apollo::drivers::gnss::config::Stream_Serial& Stream::serial() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.serial)
  return _internal_serial();
}
inline ::apollo::drivers::gnss::config::Stream_Serial* Stream::unsafe_arena_release_serial() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.drivers.gnss.config.Stream.serial)
  if (_internal_has_serial()) {
    clear_has_type();
    ::apollo::drivers::gnss::config::Stream_Serial* temp = type_.serial_;
    type_.serial_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Stream::unsafe_arena_set_allocated_serial(::apollo::drivers::gnss::config::Stream_Serial* serial) {
  clear_type();
  if (serial) {
    set_has_serial();
    type_.serial_ = serial;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.gnss.config.Stream.serial)
}
inline ::apollo::drivers::gnss::config::Stream_Serial* Stream::_internal_mutable_serial() {
  if (!_internal_has_serial()) {
    clear_type();
    set_has_serial();
    type_.serial_ = CreateMaybeMessage< ::apollo::drivers::gnss::config::Stream_Serial >(GetArenaForAllocation());
  }
  return type_.serial_;
}
inline ::apollo::drivers::gnss::config::Stream_Serial* Stream::mutable_serial() {
  ::apollo::drivers::gnss::config::Stream_Serial* _msg = _internal_mutable_serial();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Stream.serial)
  return _msg;
}

// .apollo.drivers.gnss.config.Stream.Tcp tcp = 3;
inline bool Stream::_internal_has_tcp() const {
  return type_case() == kTcp;
}
inline bool Stream::has_tcp() const {
  return _internal_has_tcp();
}
inline void Stream::set_has_tcp() {
  _oneof_case_[0] = kTcp;
}
inline void Stream::clear_tcp() {
  if (_internal_has_tcp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.tcp_;
    }
    clear_has_type();
  }
}
inline ::apollo::drivers::gnss::config::Stream_Tcp* Stream::release_tcp() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Stream.tcp)
  if (_internal_has_tcp()) {
    clear_has_type();
      ::apollo::drivers::gnss::config::Stream_Tcp* temp = type_.tcp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.tcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::drivers::gnss::config::Stream_Tcp& Stream::_internal_tcp() const {
  return _internal_has_tcp()
      ? *type_.tcp_
      : reinterpret_cast< ::apollo::drivers::gnss::config::Stream_Tcp&>(::apollo::drivers::gnss::config::_Stream_Tcp_default_instance_);
}
inline const ::apollo::drivers::gnss::config::Stream_Tcp& Stream::tcp() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.tcp)
  return _internal_tcp();
}
inline ::apollo::drivers::gnss::config::Stream_Tcp* Stream::unsafe_arena_release_tcp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.drivers.gnss.config.Stream.tcp)
  if (_internal_has_tcp()) {
    clear_has_type();
    ::apollo::drivers::gnss::config::Stream_Tcp* temp = type_.tcp_;
    type_.tcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Stream::unsafe_arena_set_allocated_tcp(::apollo::drivers::gnss::config::Stream_Tcp* tcp) {
  clear_type();
  if (tcp) {
    set_has_tcp();
    type_.tcp_ = tcp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.gnss.config.Stream.tcp)
}
inline ::apollo::drivers::gnss::config::Stream_Tcp* Stream::_internal_mutable_tcp() {
  if (!_internal_has_tcp()) {
    clear_type();
    set_has_tcp();
    type_.tcp_ = CreateMaybeMessage< ::apollo::drivers::gnss::config::Stream_Tcp >(GetArenaForAllocation());
  }
  return type_.tcp_;
}
inline ::apollo::drivers::gnss::config::Stream_Tcp* Stream::mutable_tcp() {
  ::apollo::drivers::gnss::config::Stream_Tcp* _msg = _internal_mutable_tcp();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Stream.tcp)
  return _msg;
}

// .apollo.drivers.gnss.config.Stream.Udp udp = 4;
inline bool Stream::_internal_has_udp() const {
  return type_case() == kUdp;
}
inline bool Stream::has_udp() const {
  return _internal_has_udp();
}
inline void Stream::set_has_udp() {
  _oneof_case_[0] = kUdp;
}
inline void Stream::clear_udp() {
  if (_internal_has_udp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.udp_;
    }
    clear_has_type();
  }
}
inline ::apollo::drivers::gnss::config::Stream_Udp* Stream::release_udp() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Stream.udp)
  if (_internal_has_udp()) {
    clear_has_type();
      ::apollo::drivers::gnss::config::Stream_Udp* temp = type_.udp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.udp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::drivers::gnss::config::Stream_Udp& Stream::_internal_udp() const {
  return _internal_has_udp()
      ? *type_.udp_
      : reinterpret_cast< ::apollo::drivers::gnss::config::Stream_Udp&>(::apollo::drivers::gnss::config::_Stream_Udp_default_instance_);
}
inline const ::apollo::drivers::gnss::config::Stream_Udp& Stream::udp() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.udp)
  return _internal_udp();
}
inline ::apollo::drivers::gnss::config::Stream_Udp* Stream::unsafe_arena_release_udp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.drivers.gnss.config.Stream.udp)
  if (_internal_has_udp()) {
    clear_has_type();
    ::apollo::drivers::gnss::config::Stream_Udp* temp = type_.udp_;
    type_.udp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Stream::unsafe_arena_set_allocated_udp(::apollo::drivers::gnss::config::Stream_Udp* udp) {
  clear_type();
  if (udp) {
    set_has_udp();
    type_.udp_ = udp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.gnss.config.Stream.udp)
}
inline ::apollo::drivers::gnss::config::Stream_Udp* Stream::_internal_mutable_udp() {
  if (!_internal_has_udp()) {
    clear_type();
    set_has_udp();
    type_.udp_ = CreateMaybeMessage< ::apollo::drivers::gnss::config::Stream_Udp >(GetArenaForAllocation());
  }
  return type_.udp_;
}
inline ::apollo::drivers::gnss::config::Stream_Udp* Stream::mutable_udp() {
  ::apollo::drivers::gnss::config::Stream_Udp* _msg = _internal_mutable_udp();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Stream.udp)
  return _msg;
}

// .apollo.drivers.gnss.config.Stream.Ntrip ntrip = 5;
inline bool Stream::_internal_has_ntrip() const {
  return type_case() == kNtrip;
}
inline bool Stream::has_ntrip() const {
  return _internal_has_ntrip();
}
inline void Stream::set_has_ntrip() {
  _oneof_case_[0] = kNtrip;
}
inline void Stream::clear_ntrip() {
  if (_internal_has_ntrip()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.ntrip_;
    }
    clear_has_type();
  }
}
inline ::apollo::drivers::gnss::config::Stream_Ntrip* Stream::release_ntrip() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Stream.ntrip)
  if (_internal_has_ntrip()) {
    clear_has_type();
      ::apollo::drivers::gnss::config::Stream_Ntrip* temp = type_.ntrip_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.ntrip_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::drivers::gnss::config::Stream_Ntrip& Stream::_internal_ntrip() const {
  return _internal_has_ntrip()
      ? *type_.ntrip_
      : reinterpret_cast< ::apollo::drivers::gnss::config::Stream_Ntrip&>(::apollo::drivers::gnss::config::_Stream_Ntrip_default_instance_);
}
inline const ::apollo::drivers::gnss::config::Stream_Ntrip& Stream::ntrip() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.ntrip)
  return _internal_ntrip();
}
inline ::apollo::drivers::gnss::config::Stream_Ntrip* Stream::unsafe_arena_release_ntrip() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.drivers.gnss.config.Stream.ntrip)
  if (_internal_has_ntrip()) {
    clear_has_type();
    ::apollo::drivers::gnss::config::Stream_Ntrip* temp = type_.ntrip_;
    type_.ntrip_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Stream::unsafe_arena_set_allocated_ntrip(::apollo::drivers::gnss::config::Stream_Ntrip* ntrip) {
  clear_type();
  if (ntrip) {
    set_has_ntrip();
    type_.ntrip_ = ntrip;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.gnss.config.Stream.ntrip)
}
inline ::apollo::drivers::gnss::config::Stream_Ntrip* Stream::_internal_mutable_ntrip() {
  if (!_internal_has_ntrip()) {
    clear_type();
    set_has_ntrip();
    type_.ntrip_ = CreateMaybeMessage< ::apollo::drivers::gnss::config::Stream_Ntrip >(GetArenaForAllocation());
  }
  return type_.ntrip_;
}
inline ::apollo::drivers::gnss::config::Stream_Ntrip* Stream::mutable_ntrip() {
  ::apollo::drivers::gnss::config::Stream_Ntrip* _msg = _internal_mutable_ntrip();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Stream.ntrip)
  return _msg;
}

// optional bool push_location = 6;
inline bool Stream::_internal_has_push_location() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Stream::has_push_location() const {
  return _internal_has_push_location();
}
inline void Stream::clear_push_location() {
  push_location_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool Stream::_internal_push_location() const {
  return push_location_;
}
inline bool Stream::push_location() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Stream.push_location)
  return _internal_push_location();
}
inline void Stream::_internal_set_push_location(bool value) {
  _has_bits_[0] |= 0x00000002u;
  push_location_ = value;
}
inline void Stream::set_push_location(bool value) {
  _internal_set_push_location(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Stream.push_location)
}

inline bool Stream::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Stream::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Stream::TypeCase Stream::type_case() const {
  return Stream::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NovatelConfig

// optional int32 imu_orientation = 1 [default = 5];
inline bool NovatelConfig::_internal_has_imu_orientation() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NovatelConfig::has_imu_orientation() const {
  return _internal_has_imu_orientation();
}
inline void NovatelConfig::clear_imu_orientation() {
  imu_orientation_ = 5;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NovatelConfig::_internal_imu_orientation() const {
  return imu_orientation_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NovatelConfig::imu_orientation() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.NovatelConfig.imu_orientation)
  return _internal_imu_orientation();
}
inline void NovatelConfig::_internal_set_imu_orientation(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  imu_orientation_ = value;
}
inline void NovatelConfig::set_imu_orientation(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_imu_orientation(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.NovatelConfig.imu_orientation)
}

// -------------------------------------------------------------------

// UbloxConfig

// -------------------------------------------------------------------

// TF

// optional string frame_id = 1 [default = "world"];
inline bool TF::_internal_has_frame_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TF::has_frame_id() const {
  return _internal_has_frame_id();
}
inline void TF::clear_frame_id() {
  frame_id_.ClearToDefault(::apollo::drivers::gnss::config::TF::_i_give_permission_to_break_this_code_default_frame_id_, GetArenaForAllocation());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TF::frame_id() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.TF.frame_id)
  if (frame_id_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_frame_id_.get();
  return _internal_frame_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TF::set_frame_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 frame_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.TF.frame_id)
}
inline std::string* TF::mutable_frame_id() {
  std::string* _s = _internal_mutable_frame_id();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.TF.frame_id)
  return _s;
}
inline const std::string& TF::_internal_frame_id() const {
  return frame_id_.Get();
}
inline void TF::_internal_set_frame_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  frame_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TF::_internal_mutable_frame_id() {
  _has_bits_[0] |= 0x00000001u;
  return frame_id_.Mutable(::apollo::drivers::gnss::config::TF::_i_give_permission_to_break_this_code_default_frame_id_, GetArenaForAllocation());
}
inline std::string* TF::release_frame_id() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.TF.frame_id)
  if (!_internal_has_frame_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return frame_id_.ReleaseNonDefault(nullptr, GetArenaForAllocation());
}
inline void TF::set_allocated_frame_id(std::string* frame_id) {
  if (frame_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  frame_id_.SetAllocated(nullptr, frame_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.TF.frame_id)
}

// optional string child_frame_id = 2 [default = "novatel"];
inline bool TF::_internal_has_child_frame_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TF::has_child_frame_id() const {
  return _internal_has_child_frame_id();
}
inline void TF::clear_child_frame_id() {
  child_frame_id_.ClearToDefault(::apollo::drivers::gnss::config::TF::_i_give_permission_to_break_this_code_default_child_frame_id_, GetArenaForAllocation());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TF::child_frame_id() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.TF.child_frame_id)
  if (child_frame_id_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_child_frame_id_.get();
  return _internal_child_frame_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TF::set_child_frame_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 child_frame_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.TF.child_frame_id)
}
inline std::string* TF::mutable_child_frame_id() {
  std::string* _s = _internal_mutable_child_frame_id();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.TF.child_frame_id)
  return _s;
}
inline const std::string& TF::_internal_child_frame_id() const {
  return child_frame_id_.Get();
}
inline void TF::_internal_set_child_frame_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  child_frame_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TF::_internal_mutable_child_frame_id() {
  _has_bits_[0] |= 0x00000002u;
  return child_frame_id_.Mutable(::apollo::drivers::gnss::config::TF::_i_give_permission_to_break_this_code_default_child_frame_id_, GetArenaForAllocation());
}
inline std::string* TF::release_child_frame_id() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.TF.child_frame_id)
  if (!_internal_has_child_frame_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return child_frame_id_.ReleaseNonDefault(nullptr, GetArenaForAllocation());
}
inline void TF::set_allocated_child_frame_id(std::string* child_frame_id) {
  if (child_frame_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  child_frame_id_.SetAllocated(nullptr, child_frame_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.TF.child_frame_id)
}

// optional bool enable = 3 [default = false];
inline bool TF::_internal_has_enable() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TF::has_enable() const {
  return _internal_has_enable();
}
inline void TF::clear_enable() {
  enable_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool TF::_internal_enable() const {
  return enable_;
}
inline bool TF::enable() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.TF.enable)
  return _internal_enable();
}
inline void TF::_internal_set_enable(bool value) {
  _has_bits_[0] |= 0x00000004u;
  enable_ = value;
}
inline void TF::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.TF.enable)
}

// -------------------------------------------------------------------

// Config

// optional .apollo.drivers.gnss.config.Stream data = 1;
inline bool Config::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || data_ != nullptr);
  return value;
}
inline bool Config::has_data() const {
  return _internal_has_data();
}
inline void Config::clear_data() {
  if (data_ != nullptr) data_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::apollo::drivers::gnss::config::Stream& Config::_internal_data() const {
  const ::apollo::drivers::gnss::config::Stream* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::drivers::gnss::config::Stream&>(
      ::apollo::drivers::gnss::config::_Stream_default_instance_);
}
inline const ::apollo::drivers::gnss::config::Stream& Config::data() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Config.data)
  return _internal_data();
}
inline void Config::unsafe_arena_set_allocated_data(
    ::apollo::drivers::gnss::config::Stream* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.gnss.config.Config.data)
}
inline ::apollo::drivers::gnss::config::Stream* Config::release_data() {
  _has_bits_[0] &= ~0x00000008u;
  ::apollo::drivers::gnss::config::Stream* temp = data_;
  data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::drivers::gnss::config::Stream* Config::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Config.data)
  _has_bits_[0] &= ~0x00000008u;
  ::apollo::drivers::gnss::config::Stream* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::apollo::drivers::gnss::config::Stream* Config::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000008u;
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::drivers::gnss::config::Stream>(GetArenaForAllocation());
    data_ = p;
  }
  return data_;
}
inline ::apollo::drivers::gnss::config::Stream* Config::mutable_data() {
  ::apollo::drivers::gnss::config::Stream* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Config.data)
  return _msg;
}
inline void Config::set_allocated_data(::apollo::drivers::gnss::config::Stream* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::apollo::drivers::gnss::config::Stream>::GetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Config.data)
}

// optional .apollo.drivers.gnss.config.Stream command = 2;
inline bool Config::_internal_has_command() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || command_ != nullptr);
  return value;
}
inline bool Config::has_command() const {
  return _internal_has_command();
}
inline void Config::clear_command() {
  if (command_ != nullptr) command_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::apollo::drivers::gnss::config::Stream& Config::_internal_command() const {
  const ::apollo::drivers::gnss::config::Stream* p = command_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::drivers::gnss::config::Stream&>(
      ::apollo::drivers::gnss::config::_Stream_default_instance_);
}
inline const ::apollo::drivers::gnss::config::Stream& Config::command() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Config.command)
  return _internal_command();
}
inline void Config::unsafe_arena_set_allocated_command(
    ::apollo::drivers::gnss::config::Stream* command) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(command_);
  }
  command_ = command;
  if (command) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.gnss.config.Config.command)
}
inline ::apollo::drivers::gnss::config::Stream* Config::release_command() {
  _has_bits_[0] &= ~0x00000010u;
  ::apollo::drivers::gnss::config::Stream* temp = command_;
  command_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::drivers::gnss::config::Stream* Config::unsafe_arena_release_command() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Config.command)
  _has_bits_[0] &= ~0x00000010u;
  ::apollo::drivers::gnss::config::Stream* temp = command_;
  command_ = nullptr;
  return temp;
}
inline ::apollo::drivers::gnss::config::Stream* Config::_internal_mutable_command() {
  _has_bits_[0] |= 0x00000010u;
  if (command_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::drivers::gnss::config::Stream>(GetArenaForAllocation());
    command_ = p;
  }
  return command_;
}
inline ::apollo::drivers::gnss::config::Stream* Config::mutable_command() {
  ::apollo::drivers::gnss::config::Stream* _msg = _internal_mutable_command();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Config.command)
  return _msg;
}
inline void Config::set_allocated_command(::apollo::drivers::gnss::config::Stream* command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete command_;
  }
  if (command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::apollo::drivers::gnss::config::Stream>::GetOwningArena(command);
    if (message_arena != submessage_arena) {
      command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Config.command)
}

// optional .apollo.drivers.gnss.config.Stream rtk_from = 3;
inline bool Config::_internal_has_rtk_from() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || rtk_from_ != nullptr);
  return value;
}
inline bool Config::has_rtk_from() const {
  return _internal_has_rtk_from();
}
inline void Config::clear_rtk_from() {
  if (rtk_from_ != nullptr) rtk_from_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::apollo::drivers::gnss::config::Stream& Config::_internal_rtk_from() const {
  const ::apollo::drivers::gnss::config::Stream* p = rtk_from_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::drivers::gnss::config::Stream&>(
      ::apollo::drivers::gnss::config::_Stream_default_instance_);
}
inline const ::apollo::drivers::gnss::config::Stream& Config::rtk_from() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Config.rtk_from)
  return _internal_rtk_from();
}
inline void Config::unsafe_arena_set_allocated_rtk_from(
    ::apollo::drivers::gnss::config::Stream* rtk_from) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rtk_from_);
  }
  rtk_from_ = rtk_from;
  if (rtk_from) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.gnss.config.Config.rtk_from)
}
inline ::apollo::drivers::gnss::config::Stream* Config::release_rtk_from() {
  _has_bits_[0] &= ~0x00000020u;
  ::apollo::drivers::gnss::config::Stream* temp = rtk_from_;
  rtk_from_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::drivers::gnss::config::Stream* Config::unsafe_arena_release_rtk_from() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Config.rtk_from)
  _has_bits_[0] &= ~0x00000020u;
  ::apollo::drivers::gnss::config::Stream* temp = rtk_from_;
  rtk_from_ = nullptr;
  return temp;
}
inline ::apollo::drivers::gnss::config::Stream* Config::_internal_mutable_rtk_from() {
  _has_bits_[0] |= 0x00000020u;
  if (rtk_from_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::drivers::gnss::config::Stream>(GetArenaForAllocation());
    rtk_from_ = p;
  }
  return rtk_from_;
}
inline ::apollo::drivers::gnss::config::Stream* Config::mutable_rtk_from() {
  ::apollo::drivers::gnss::config::Stream* _msg = _internal_mutable_rtk_from();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Config.rtk_from)
  return _msg;
}
inline void Config::set_allocated_rtk_from(::apollo::drivers::gnss::config::Stream* rtk_from) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rtk_from_;
  }
  if (rtk_from) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::apollo::drivers::gnss::config::Stream>::GetOwningArena(rtk_from);
    if (message_arena != submessage_arena) {
      rtk_from = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rtk_from, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  rtk_from_ = rtk_from;
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Config.rtk_from)
}

// optional .apollo.drivers.gnss.config.Stream rtk_to = 4;
inline bool Config::_internal_has_rtk_to() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || rtk_to_ != nullptr);
  return value;
}
inline bool Config::has_rtk_to() const {
  return _internal_has_rtk_to();
}
inline void Config::clear_rtk_to() {
  if (rtk_to_ != nullptr) rtk_to_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::apollo::drivers::gnss::config::Stream& Config::_internal_rtk_to() const {
  const ::apollo::drivers::gnss::config::Stream* p = rtk_to_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::drivers::gnss::config::Stream&>(
      ::apollo::drivers::gnss::config::_Stream_default_instance_);
}
inline const ::apollo::drivers::gnss::config::Stream& Config::rtk_to() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Config.rtk_to)
  return _internal_rtk_to();
}
inline void Config::unsafe_arena_set_allocated_rtk_to(
    ::apollo::drivers::gnss::config::Stream* rtk_to) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rtk_to_);
  }
  rtk_to_ = rtk_to;
  if (rtk_to) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.gnss.config.Config.rtk_to)
}
inline ::apollo::drivers::gnss::config::Stream* Config::release_rtk_to() {
  _has_bits_[0] &= ~0x00000040u;
  ::apollo::drivers::gnss::config::Stream* temp = rtk_to_;
  rtk_to_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::drivers::gnss::config::Stream* Config::unsafe_arena_release_rtk_to() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Config.rtk_to)
  _has_bits_[0] &= ~0x00000040u;
  ::apollo::drivers::gnss::config::Stream* temp = rtk_to_;
  rtk_to_ = nullptr;
  return temp;
}
inline ::apollo::drivers::gnss::config::Stream* Config::_internal_mutable_rtk_to() {
  _has_bits_[0] |= 0x00000040u;
  if (rtk_to_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::drivers::gnss::config::Stream>(GetArenaForAllocation());
    rtk_to_ = p;
  }
  return rtk_to_;
}
inline ::apollo::drivers::gnss::config::Stream* Config::mutable_rtk_to() {
  ::apollo::drivers::gnss::config::Stream* _msg = _internal_mutable_rtk_to();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Config.rtk_to)
  return _msg;
}
inline void Config::set_allocated_rtk_to(::apollo::drivers::gnss::config::Stream* rtk_to) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rtk_to_;
  }
  if (rtk_to) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::apollo::drivers::gnss::config::Stream>::GetOwningArena(rtk_to);
    if (message_arena != submessage_arena) {
      rtk_to = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rtk_to, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  rtk_to_ = rtk_to;
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Config.rtk_to)
}

// repeated bytes login_commands = 5;
inline int Config::_internal_login_commands_size() const {
  return login_commands_.size();
}
inline int Config::login_commands_size() const {
  return _internal_login_commands_size();
}
inline void Config::clear_login_commands() {
  login_commands_.Clear();
}
inline std::string* Config::add_login_commands() {
  std::string* _s = _internal_add_login_commands();
  // @@protoc_insertion_point(field_add_mutable:apollo.drivers.gnss.config.Config.login_commands)
  return _s;
}
inline const std::string& Config::_internal_login_commands(int index) const {
  return login_commands_.Get(index);
}
inline const std::string& Config::login_commands(int index) const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Config.login_commands)
  return _internal_login_commands(index);
}
inline std::string* Config::mutable_login_commands(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Config.login_commands)
  return login_commands_.Mutable(index);
}
inline void Config::set_login_commands(int index, const std::string& value) {
  login_commands_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Config.login_commands)
}
inline void Config::set_login_commands(int index, std::string&& value) {
  login_commands_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Config.login_commands)
}
inline void Config::set_login_commands(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  login_commands_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.drivers.gnss.config.Config.login_commands)
}
inline void Config::set_login_commands(int index, const void* value, size_t size) {
  login_commands_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.drivers.gnss.config.Config.login_commands)
}
inline std::string* Config::_internal_add_login_commands() {
  return login_commands_.Add();
}
inline void Config::add_login_commands(const std::string& value) {
  login_commands_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.drivers.gnss.config.Config.login_commands)
}
inline void Config::add_login_commands(std::string&& value) {
  login_commands_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.drivers.gnss.config.Config.login_commands)
}
inline void Config::add_login_commands(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  login_commands_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.drivers.gnss.config.Config.login_commands)
}
inline void Config::add_login_commands(const void* value, size_t size) {
  login_commands_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.drivers.gnss.config.Config.login_commands)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Config::login_commands() const {
  // @@protoc_insertion_point(field_list:apollo.drivers.gnss.config.Config.login_commands)
  return login_commands_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Config::mutable_login_commands() {
  // @@protoc_insertion_point(field_mutable_list:apollo.drivers.gnss.config.Config.login_commands)
  return &login_commands_;
}

// repeated bytes logout_commands = 6;
inline int Config::_internal_logout_commands_size() const {
  return logout_commands_.size();
}
inline int Config::logout_commands_size() const {
  return _internal_logout_commands_size();
}
inline void Config::clear_logout_commands() {
  logout_commands_.Clear();
}
inline std::string* Config::add_logout_commands() {
  std::string* _s = _internal_add_logout_commands();
  // @@protoc_insertion_point(field_add_mutable:apollo.drivers.gnss.config.Config.logout_commands)
  return _s;
}
inline const std::string& Config::_internal_logout_commands(int index) const {
  return logout_commands_.Get(index);
}
inline const std::string& Config::logout_commands(int index) const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Config.logout_commands)
  return _internal_logout_commands(index);
}
inline std::string* Config::mutable_logout_commands(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Config.logout_commands)
  return logout_commands_.Mutable(index);
}
inline void Config::set_logout_commands(int index, const std::string& value) {
  logout_commands_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Config.logout_commands)
}
inline void Config::set_logout_commands(int index, std::string&& value) {
  logout_commands_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Config.logout_commands)
}
inline void Config::set_logout_commands(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  logout_commands_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.drivers.gnss.config.Config.logout_commands)
}
inline void Config::set_logout_commands(int index, const void* value, size_t size) {
  logout_commands_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.drivers.gnss.config.Config.logout_commands)
}
inline std::string* Config::_internal_add_logout_commands() {
  return logout_commands_.Add();
}
inline void Config::add_logout_commands(const std::string& value) {
  logout_commands_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.drivers.gnss.config.Config.logout_commands)
}
inline void Config::add_logout_commands(std::string&& value) {
  logout_commands_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.drivers.gnss.config.Config.logout_commands)
}
inline void Config::add_logout_commands(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  logout_commands_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.drivers.gnss.config.Config.logout_commands)
}
inline void Config::add_logout_commands(const void* value, size_t size) {
  logout_commands_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.drivers.gnss.config.Config.logout_commands)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Config::logout_commands() const {
  // @@protoc_insertion_point(field_list:apollo.drivers.gnss.config.Config.logout_commands)
  return logout_commands_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Config::mutable_logout_commands() {
  // @@protoc_insertion_point(field_mutable_list:apollo.drivers.gnss.config.Config.logout_commands)
  return &logout_commands_;
}

// .apollo.drivers.gnss.config.NovatelConfig novatel_config = 7;
inline bool Config::_internal_has_novatel_config() const {
  return device_config_case() == kNovatelConfig;
}
inline bool Config::has_novatel_config() const {
  return _internal_has_novatel_config();
}
inline void Config::set_has_novatel_config() {
  _oneof_case_[0] = kNovatelConfig;
}
inline void Config::clear_novatel_config() {
  if (_internal_has_novatel_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete device_config_.novatel_config_;
    }
    clear_has_device_config();
  }
}
inline ::apollo::drivers::gnss::config::NovatelConfig* Config::release_novatel_config() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Config.novatel_config)
  if (_internal_has_novatel_config()) {
    clear_has_device_config();
      ::apollo::drivers::gnss::config::NovatelConfig* temp = device_config_.novatel_config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    device_config_.novatel_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::drivers::gnss::config::NovatelConfig& Config::_internal_novatel_config() const {
  return _internal_has_novatel_config()
      ? *device_config_.novatel_config_
      : reinterpret_cast< ::apollo::drivers::gnss::config::NovatelConfig&>(::apollo::drivers::gnss::config::_NovatelConfig_default_instance_);
}
inline const ::apollo::drivers::gnss::config::NovatelConfig& Config::novatel_config() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Config.novatel_config)
  return _internal_novatel_config();
}
inline ::apollo::drivers::gnss::config::NovatelConfig* Config::unsafe_arena_release_novatel_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.drivers.gnss.config.Config.novatel_config)
  if (_internal_has_novatel_config()) {
    clear_has_device_config();
    ::apollo::drivers::gnss::config::NovatelConfig* temp = device_config_.novatel_config_;
    device_config_.novatel_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Config::unsafe_arena_set_allocated_novatel_config(::apollo::drivers::gnss::config::NovatelConfig* novatel_config) {
  clear_device_config();
  if (novatel_config) {
    set_has_novatel_config();
    device_config_.novatel_config_ = novatel_config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.gnss.config.Config.novatel_config)
}
inline ::apollo::drivers::gnss::config::NovatelConfig* Config::_internal_mutable_novatel_config() {
  if (!_internal_has_novatel_config()) {
    clear_device_config();
    set_has_novatel_config();
    device_config_.novatel_config_ = CreateMaybeMessage< ::apollo::drivers::gnss::config::NovatelConfig >(GetArenaForAllocation());
  }
  return device_config_.novatel_config_;
}
inline ::apollo::drivers::gnss::config::NovatelConfig* Config::mutable_novatel_config() {
  ::apollo::drivers::gnss::config::NovatelConfig* _msg = _internal_mutable_novatel_config();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Config.novatel_config)
  return _msg;
}

// .apollo.drivers.gnss.config.UbloxConfig ublox_config = 8;
inline bool Config::_internal_has_ublox_config() const {
  return device_config_case() == kUbloxConfig;
}
inline bool Config::has_ublox_config() const {
  return _internal_has_ublox_config();
}
inline void Config::set_has_ublox_config() {
  _oneof_case_[0] = kUbloxConfig;
}
inline void Config::clear_ublox_config() {
  if (_internal_has_ublox_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete device_config_.ublox_config_;
    }
    clear_has_device_config();
  }
}
inline ::apollo::drivers::gnss::config::UbloxConfig* Config::release_ublox_config() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Config.ublox_config)
  if (_internal_has_ublox_config()) {
    clear_has_device_config();
      ::apollo::drivers::gnss::config::UbloxConfig* temp = device_config_.ublox_config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    device_config_.ublox_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::drivers::gnss::config::UbloxConfig& Config::_internal_ublox_config() const {
  return _internal_has_ublox_config()
      ? *device_config_.ublox_config_
      : reinterpret_cast< ::apollo::drivers::gnss::config::UbloxConfig&>(::apollo::drivers::gnss::config::_UbloxConfig_default_instance_);
}
inline const ::apollo::drivers::gnss::config::UbloxConfig& Config::ublox_config() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Config.ublox_config)
  return _internal_ublox_config();
}
inline ::apollo::drivers::gnss::config::UbloxConfig* Config::unsafe_arena_release_ublox_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.drivers.gnss.config.Config.ublox_config)
  if (_internal_has_ublox_config()) {
    clear_has_device_config();
    ::apollo::drivers::gnss::config::UbloxConfig* temp = device_config_.ublox_config_;
    device_config_.ublox_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Config::unsafe_arena_set_allocated_ublox_config(::apollo::drivers::gnss::config::UbloxConfig* ublox_config) {
  clear_device_config();
  if (ublox_config) {
    set_has_ublox_config();
    device_config_.ublox_config_ = ublox_config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.gnss.config.Config.ublox_config)
}
inline ::apollo::drivers::gnss::config::UbloxConfig* Config::_internal_mutable_ublox_config() {
  if (!_internal_has_ublox_config()) {
    clear_device_config();
    set_has_ublox_config();
    device_config_.ublox_config_ = CreateMaybeMessage< ::apollo::drivers::gnss::config::UbloxConfig >(GetArenaForAllocation());
  }
  return device_config_.ublox_config_;
}
inline ::apollo::drivers::gnss::config::UbloxConfig* Config::mutable_ublox_config() {
  ::apollo::drivers::gnss::config::UbloxConfig* _msg = _internal_mutable_ublox_config();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Config.ublox_config)
  return _msg;
}

// optional .apollo.drivers.gnss.config.Config.RtkSolutionType rtk_solution_type = 9;
inline bool Config::_internal_has_rtk_solution_type() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Config::has_rtk_solution_type() const {
  return _internal_has_rtk_solution_type();
}
inline void Config::clear_rtk_solution_type() {
  rtk_solution_type_ = 1;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::apollo::drivers::gnss::config::Config_RtkSolutionType Config::_internal_rtk_solution_type() const {
  return static_cast< ::apollo::drivers::gnss::config::Config_RtkSolutionType >(rtk_solution_type_);
}
inline ::apollo::drivers::gnss::config::Config_RtkSolutionType Config::rtk_solution_type() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Config.rtk_solution_type)
  return _internal_rtk_solution_type();
}
inline void Config::_internal_set_rtk_solution_type(::apollo::drivers::gnss::config::Config_RtkSolutionType value) {
  assert(::apollo::drivers::gnss::config::Config_RtkSolutionType_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  rtk_solution_type_ = value;
}
inline void Config::set_rtk_solution_type(::apollo::drivers::gnss::config::Config_RtkSolutionType value) {
  _internal_set_rtk_solution_type(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Config.rtk_solution_type)
}

// optional .apollo.drivers.gnss.config.ImuType imu_type = 10;
inline bool Config::_internal_has_imu_type() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Config::has_imu_type() const {
  return _internal_has_imu_type();
}
inline void Config::clear_imu_type() {
  imu_type_ = 13;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::apollo::drivers::gnss::config::ImuType Config::_internal_imu_type() const {
  return static_cast< ::apollo::drivers::gnss::config::ImuType >(imu_type_);
}
inline ::apollo::drivers::gnss::config::ImuType Config::imu_type() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Config.imu_type)
  return _internal_imu_type();
}
inline void Config::_internal_set_imu_type(::apollo::drivers::gnss::config::ImuType value) {
  assert(::apollo::drivers::gnss::config::ImuType_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  imu_type_ = value;
}
inline void Config::set_imu_type(::apollo::drivers::gnss::config::ImuType value) {
  _internal_set_imu_type(value);
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Config.imu_type)
}

// optional string proj4_text = 11;
inline bool Config::_internal_has_proj4_text() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Config::has_proj4_text() const {
  return _internal_has_proj4_text();
}
inline void Config::clear_proj4_text() {
  proj4_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Config::proj4_text() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Config.proj4_text)
  return _internal_proj4_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Config::set_proj4_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 proj4_text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Config.proj4_text)
}
inline std::string* Config::mutable_proj4_text() {
  std::string* _s = _internal_mutable_proj4_text();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Config.proj4_text)
  return _s;
}
inline const std::string& Config::_internal_proj4_text() const {
  return proj4_text_.Get();
}
inline void Config::_internal_set_proj4_text(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  proj4_text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Config::_internal_mutable_proj4_text() {
  _has_bits_[0] |= 0x00000001u;
  return proj4_text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Config::release_proj4_text() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Config.proj4_text)
  if (!_internal_has_proj4_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return proj4_text_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Config::set_allocated_proj4_text(std::string* proj4_text) {
  if (proj4_text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  proj4_text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), proj4_text,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Config.proj4_text)
}

// optional .apollo.drivers.gnss.config.TF tf = 12;
inline bool Config::_internal_has_tf() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || tf_ != nullptr);
  return value;
}
inline bool Config::has_tf() const {
  return _internal_has_tf();
}
inline void Config::clear_tf() {
  if (tf_ != nullptr) tf_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::apollo::drivers::gnss::config::TF& Config::_internal_tf() const {
  const ::apollo::drivers::gnss::config::TF* p = tf_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::drivers::gnss::config::TF&>(
      ::apollo::drivers::gnss::config::_TF_default_instance_);
}
inline const ::apollo::drivers::gnss::config::TF& Config::tf() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Config.tf)
  return _internal_tf();
}
inline void Config::unsafe_arena_set_allocated_tf(
    ::apollo::drivers::gnss::config::TF* tf) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tf_);
  }
  tf_ = tf;
  if (tf) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.drivers.gnss.config.Config.tf)
}
inline ::apollo::drivers::gnss::config::TF* Config::release_tf() {
  _has_bits_[0] &= ~0x00000080u;
  ::apollo::drivers::gnss::config::TF* temp = tf_;
  tf_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::apollo::drivers::gnss::config::TF* Config::unsafe_arena_release_tf() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Config.tf)
  _has_bits_[0] &= ~0x00000080u;
  ::apollo::drivers::gnss::config::TF* temp = tf_;
  tf_ = nullptr;
  return temp;
}
inline ::apollo::drivers::gnss::config::TF* Config::_internal_mutable_tf() {
  _has_bits_[0] |= 0x00000080u;
  if (tf_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::drivers::gnss::config::TF>(GetArenaForAllocation());
    tf_ = p;
  }
  return tf_;
}
inline ::apollo::drivers::gnss::config::TF* Config::mutable_tf() {
  ::apollo::drivers::gnss::config::TF* _msg = _internal_mutable_tf();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Config.tf)
  return _msg;
}
inline void Config::set_allocated_tf(::apollo::drivers::gnss::config::TF* tf) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete tf_;
  }
  if (tf) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::apollo::drivers::gnss::config::TF>::GetOwningArena(tf);
    if (message_arena != submessage_arena) {
      tf = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tf, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  tf_ = tf;
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Config.tf)
}

// optional string wheel_parameters = 13;
inline bool Config::_internal_has_wheel_parameters() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Config::has_wheel_parameters() const {
  return _internal_has_wheel_parameters();
}
inline void Config::clear_wheel_parameters() {
  wheel_parameters_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Config::wheel_parameters() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Config.wheel_parameters)
  return _internal_wheel_parameters();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Config::set_wheel_parameters(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 wheel_parameters_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Config.wheel_parameters)
}
inline std::string* Config::mutable_wheel_parameters() {
  std::string* _s = _internal_mutable_wheel_parameters();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Config.wheel_parameters)
  return _s;
}
inline const std::string& Config::_internal_wheel_parameters() const {
  return wheel_parameters_.Get();
}
inline void Config::_internal_set_wheel_parameters(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  wheel_parameters_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Config::_internal_mutable_wheel_parameters() {
  _has_bits_[0] |= 0x00000002u;
  return wheel_parameters_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Config::release_wheel_parameters() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Config.wheel_parameters)
  if (!_internal_has_wheel_parameters()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return wheel_parameters_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Config::set_allocated_wheel_parameters(std::string* wheel_parameters) {
  if (wheel_parameters != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  wheel_parameters_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), wheel_parameters,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Config.wheel_parameters)
}

// optional string gpsbin_folder = 14;
inline bool Config::_internal_has_gpsbin_folder() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Config::has_gpsbin_folder() const {
  return _internal_has_gpsbin_folder();
}
inline void Config::clear_gpsbin_folder() {
  gpsbin_folder_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Config::gpsbin_folder() const {
  // @@protoc_insertion_point(field_get:apollo.drivers.gnss.config.Config.gpsbin_folder)
  return _internal_gpsbin_folder();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Config::set_gpsbin_folder(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 gpsbin_folder_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apollo.drivers.gnss.config.Config.gpsbin_folder)
}
inline std::string* Config::mutable_gpsbin_folder() {
  std::string* _s = _internal_mutable_gpsbin_folder();
  // @@protoc_insertion_point(field_mutable:apollo.drivers.gnss.config.Config.gpsbin_folder)
  return _s;
}
inline const std::string& Config::_internal_gpsbin_folder() const {
  return gpsbin_folder_.Get();
}
inline void Config::_internal_set_gpsbin_folder(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  gpsbin_folder_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Config::_internal_mutable_gpsbin_folder() {
  _has_bits_[0] |= 0x00000004u;
  return gpsbin_folder_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Config::release_gpsbin_folder() {
  // @@protoc_insertion_point(field_release:apollo.drivers.gnss.config.Config.gpsbin_folder)
  if (!_internal_has_gpsbin_folder()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return gpsbin_folder_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Config::set_allocated_gpsbin_folder(std::string* gpsbin_folder) {
  if (gpsbin_folder != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  gpsbin_folder_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gpsbin_folder,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:apollo.drivers.gnss.config.Config.gpsbin_folder)
}

inline bool Config::has_device_config() const {
  return device_config_case() != DEVICE_CONFIG_NOT_SET;
}
inline void Config::clear_has_device_config() {
  _oneof_case_[0] = DEVICE_CONFIG_NOT_SET;
}
inline Config::DeviceConfigCase Config::device_config_case() const {
  return Config::DeviceConfigCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace config
}  // namespace gnss
}  // namespace drivers
}  // namespace apollo

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::apollo::drivers::gnss::config::Stream_Format> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::drivers::gnss::config::Stream_Format>() {
  return ::apollo::drivers::gnss::config::Stream_Format_descriptor();
}
template <> struct is_proto_enum< ::apollo::drivers::gnss::config::Config_RtkSolutionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::drivers::gnss::config::Config_RtkSolutionType>() {
  return ::apollo::drivers::gnss::config::Config_RtkSolutionType_descriptor();
}
template <> struct is_proto_enum< ::apollo::drivers::gnss::config::ImuType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::drivers::gnss::config::ImuType>() {
  return ::apollo::drivers::gnss::config::ImuType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto
